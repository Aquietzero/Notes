# Reliable Data Transfer
------------------------


## 可靠数据传输

TCP是在不可靠的端对端网络层协议（IP）之上实现的可靠数据传输协议。可靠传输协议可以分为很多等级，TCP协议就是在这些可靠性方面不断细化而得出的可靠数据传输协议。

+ 当底层信道本身提供了可靠服务的时候，发送方只需要简单将数据传送到接收方即可，这样底层信道可以将数据准确托付给接收方。

+ 当底层信道具有比特差错的时候，发送方必须在确认接收方受到数据之后再监听上层应用的发送请求，故被称为停等协议。接收方用确认信息来表示其接受信息的情况，当信息到来时，如果信息比特发生错误，那么接收方发送一个否定确认，如果信息是正确的，那么接收方将数据交付给上层应用。在发送方方面，如果收到接收方的肯定确认，那么返回监听上层调用，如果收到的是否定确认，则重传数据并等待。

+ 当底层信道会发生丢包的时候，需要通过计时的方式来避免无限等待。每当发送方发送一个分组，计时器就被启动，无论是分组丢失，肯定确认丢失，还是肯定确认延时到达，发送方都会将分组再发送一次，如果之前是肯定确认延时到达的话，那么发送方所发送的分组在接收方看来是冗余的，那么发送方之后也肯定会收到一个冗余的肯定确认，这时候发送方不会做什么事情。

经过上述三个阶段，可靠数据传输就能够在具有比特差错并且有可能丢包的底层信道上建立起来了。


## 流水线可靠数据传输协议

发送方在发送一个分组之后并不会立刻进入停等状态，而是继续发送分组，集从发送方向接收方传输的众多分组可以被看成是填充到一条流水线中，故这种技术称为流水线技术。发送方最低限度应当能缓存那些已经发送但没有确认的分组，而接收方或许需要缓存那些已正确接收的分组。

解决流水线差错恢复有两种办法：**回退N步**和**选择重传**。

### 回退N步

回退N步主要采取的是累计确认技术，在发送方维护一个窗口，在接收方维护一个下一个期望到达的分组序号，具体如下：

窗口实际上是分组队列的一个小部分，其中两个变量base和nextseqnum把序列分成了四个部分：

    |||||||||||||||...............//////////////,,,,,,,,,,,,,,,
                   ^              ^
                  base        nextseqnum
                   | <--- window length N ---> |

1. 在base前面的部分是已经发送并且已经被确认的分组。
2. 在[base, nextseqnum-1]之间是已经发送但还没有被确认的分组。
3. 在[nextseqnum, N]之间的那些序号可用于那些要被立刻发送的分组，其来源于上层。
4. 在N后面的那些序号是不可用的。

在发送方看来，每当上层有数据需要发送的时候，先检查没有被确认的分组数目是否超过了N，如果窗口已经满了，那么将拒绝发送上层数据，如果窗口还有空位，那么将窗口中的nextseqnum作为下一个分组的序号，然后将窗口前移。并且发送方会使用一个定时器来进行定时，每当base前移，计时器启动，当接收到一个ACK确认，计时器就重新启动，但是当计时器超时的时候，发送方会将没有确认的分组全部重发一次。

在接收方，接收方采用的是累计确认，如果接收到的分组的序号是跟上一个向上层传递的分组是连续的话，那么接收方将这个分组向上层传递。如果接收到的分组并不是与上一次接收到的分组在序号上连续，那么接收方将丢弃着一个分组，并发送一个上次接受分组的冗余ACK。

GBN存在这严重的效率问题，一个单个分组的差错就可能引起GBN重传大量的分组，许多分组根本就没有必要重传。随着信道差错率的增加，流水线可能会被这些没有必要重传的分组填满。

### 选择重传

选择重传在发送方方面于GBN最大的差别在于，它只是会重传那些有可能出错的分组，并且在接收方，也不会因为到达分组的失序性而将收到的分组抛弃。在选择重传中，接收方也维护了一个分组，当收到失序的分组时，接收方先将其缓存，而如果在这个失序分组的前面的分组都是连续的，那么接收方将会将这些连续的分组一次过发给上层应用，并将窗口前移。**要注意的一点是，当接收方收到之前已经成功接受的冗余分组时，一个ACK是必要的，不然将迷惑发送方**。

而在发送方方面，每个分组都必须维护一个计时器，这样当计时器超时的时候，就仅仅需要重传超时分组而已。
